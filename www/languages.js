// Generated by CoffeeScript 1.4.0
(function() {
  var CategoryStars, average, background, best, byLanguage, flatten, getX0, getY0, languagesByX, languagesByXThenY, languagesByY, matrixValues, myStars, rect, rollup, setX, setY, type;

  CategoryStars = (function() {

    function CategoryStars(width, height) {
      var _ref, _ref1;
      this.width = width;
      this.height = height;
      if ((_ref = this.width) == null) {
        this.width = 40;
      }
      if ((_ref1 = this.height) == null) {
        this.height = 40;
      }
      this.row_count = 5;
      this.x_column = "cpu(s)";
      this.y_column = "size(B)";
      this.scaleX.rangeRound([0, this.width]);
      this.scaleY.rangeRound([this.height, 0]);
    }

    CategoryStars.prototype.scaleX = d3.scale.sqrt();

    CategoryStars.prototype.scaleY = d3.scale.sqrt();

    CategoryStars.prototype.lang = function(d) {
      return d.lang;
    };

    CategoryStars.prototype.getX = function(d) {
      return d[this.x_column];
    };

    CategoryStars.prototype.getY = function(d) {
      return d[this.y_column];
    };

    return CategoryStars;

  })();

  myStars = new CategoryStars;

  setX = function(d, x) {
    return d[myStars.x_column] = x;
  };

  setY = function(d, y) {
    return d[myStars.y_column] = y;
  };

  getX0 = function(d) {
    return myStars.scaleX(myStars.getX(d));
  };

  getY0 = function(d) {
    return myStars.scaleY(myStars.getY(d));
  };

  background = d3.scale.ordinal().domain(['imperative', 'oo', 'functional', 'scripting']).range(['#6da', '#97e', '#fe7', '#fa7']);

  type = function(d) {
    return background(types[d.lang]);
  };

  rollup = function(k, f) {
    return d3.nest().key(function(d) {
      return d[k];
    }).rollup(function(v) {
      var m;
      m = {};
      setX(m, d3[f](v, function(d) {
        return myStars.getX(d);
      }));
      setY(m, d3[f](v, function(d) {
        return myStars.getY(d);
      }));
      return m;
    });
  };

  average = rollup('lang', 'mean');

  best = rollup('name', 'min');

  byLanguage = d3.nest().key(myStars.lang);

  languagesByX = d3.nest().key(function(d) {
    return myStars.getX(d);
  }).sortKeys(function(a, b) {
    return d3.ascending(parseFloat(a), parseFloat(b));
  });

  languagesByY = d3.nest().key(function(d) {
    return myStars.getY(d);
  }).sortKeys(function(a, b) {
    return d3.descending(parseFloat(a), parseFloat(b));
  });

  matrixValues = function(cols) {
    var cell, col, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = cols.length; _i < _len; _i++) {
      col = cols[_i];
      _results.push((function() {
        var _j, _len1, _results1;
        _results1 = [];
        for (_j = 0, _len1 = col.length; _j < _len1; _j++) {
          cell = col[_j];
          _results1.push(cell.values[0]);
        }
        return _results1;
      })());
    }
    return _results;
  };

  languagesByXThenY = function(a) {
    var byX, chunk, col, cols, end, i;
    chunk = myStars.row_count;
    byX = languagesByX.entries(a);
    end = function(i) {
      return Math.min(byX.length - 1, i + chunk);
    };
    cols = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = byX.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = _i += chunk) {
        _results.push(byX.slice(i, end(i)));
      }
      return _results;
    })();
    cols = matrixValues(cols);
    return matrixValues((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = cols.length; _i < _len; _i++) {
        col = cols[_i];
        _results.push(languagesByY.entries(col));
      }
      return _results;
    })());
  };

  flatten = function(lng, avg) {
    var m;
    m = {};
    m.lang = lng;
    setX(m, myStars.getX(avg));
    setY(m, myStars.getY(avg));
    return m;
  };

  rect = function(c) {
    return c.append("rect").attr("width", myStars.width).attr("height", myStars.height);
  };

  d3.csv("data.csv", function(data) {
    var averages, avg, col, d, flat_averages, focus, lang_benches, layout, lines, lng, mins, spoke, star, _i, _j, _len, _len1;
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      d = data[_i];
      setX(d, parseFloat(myStars.getX(d)));
      setY(d, parseFloat(myStars.getY(d)));
    }
    mins = best.map(data);
    for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
      d = data[_j];
      setX(d, myStars.getX(d) / myStars.getX(mins[d.name]));
      setY(d, myStars.getY(d) / myStars.getY(mins[d.name]));
    }
    myStars.scaleX.domain([0, 5000]);
    myStars.scaleY.domain([1, 6]);
    averages = average.map(data);
    flat_averages = (function() {
      var _results;
      _results = [];
      for (lng in averages) {
        avg = averages[lng];
        _results.push(flatten(lng, avg));
      }
      return _results;
    })();
    layout = languagesByXThenY(flat_averages);
    lang_benches = byLanguage.map(data);
    spoke = function(d) {
      var cx, cy;
      avg = averages[d.lang];
      cx = getX0(d) - getX0(avg);
      cy = getY0(d) - getY0(avg);
      return "M 0 0 L " + cx + " " + cy;
    };
    col = d3.select("#viz").selectAll(".col").data(layout).enter().append("div").classed("col", function() {
      return true;
    });
    focus = smallMultiples(col, {
      width: myStars.width,
      height: myStars.height,
      margin: {
        left: 40,
        right: 40,
        top: 10,
        bottom: 10
      },
      title: {
        size: 10,
        padding: 5,
        data: myStars.lang
      }
    });
    rect(focus).attr("fill", type);
    star = focus.append("g").classed("star", function() {
      return true;
    }).attr("transform", function(d) {
      avg = averages[d.lang];
      return "translate(" + (getX0(avg)) + "," + (getY0(avg)) + ")";
    });
    lines = star.selectAll("path").data(function(d) {
      return lang_benches[d.lang];
    }).enter().append("path").attr("d", spoke);
    return rect(focus).classed('border', function() {
      return true;
    });
  });

}).call(this);
